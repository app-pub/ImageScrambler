
# ImageScrambler

[![AOT Ready](https://img.shields.io/badge/AOT-Ready-green.svg)](https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot/)

一个基于色度通道重组和数据块置换的图像隐写工具，旨在将一个图像（“隐藏图像”）的数据编码到另一个图像（“载体图像”）的亮度通道中。

## 主要特性

- **图像编码**: 基于 YCbCr 色彩空间，将隐藏图像的完整数据嵌入载体图像的亮度（Y）通道。
- **数据置换**: 可选的数据块置换功能，用于混淆编码后的数据。
- **密码保护**: 使用基于 HMAC-SHA256 的密钥派生函数 (KDF) 生成加密操作所需的盐（Salt）和种子（Seed）。
- **跨平台**: 支持 Windows, macOS, 和 Linux 上运行。
- **原生编译**: 支持通过 Native AOT 发布为独立的、自包含的本地应用程序。
- **多语言支持**: 自动检测系统语言并在简体中文、繁體中文和英文之间切换。

## 算法原理

编码过程包含三个核心步骤：色度通道重组、数据块置换和载体生成。解码是此过程的逆操作。

### 1. 色度通道重组

此步骤将隐藏图像 `I_H`（尺寸为 `W × H`）转换为一维数据向量。

1.  **色彩空间转换**: 将隐藏图像 `I_H` 的每个像素 `P(R, G, B)` 转换为 YCbCr 色彩空间中的 `P'(Y, Cb, Cr)`。此转换基于 [ITU-R BT.601 标准](https://www.itu.int/rec/R-REC-BT.601)。
2.  **通道分离**: 分离所有像素的 Y, Cb, Cr 分量，形成三个独立的字节数组：`Array_Y`, `Array_Cb`, `Array_Cr`，每个数组的长度为 `W × H`。
3.  **数据串联**: 将三个字节数组按顺序串联成一个单一的数据向量 `V`：`V = [Array_Y | Array_Cb | Array_Cr]`。`V` 的总长度为 `3 × W × H`。

### 2. 数据块置换（可选）

此步骤通过伪随机置换来混淆数据向量 `V` 的内部结构。

1.  **种子生成**: 使用用户密码和派生出的盐（Salt），通过 `HMAC-SHA256` 函数生成一个确定性的 32 位整数作为种子（Seed）。
    - `PRK = HMAC-SHA256(salt, password)`
    - `Seed = ToInt32(HMAC-SHA256(PRK, context_info))`
2.  **置换表生成**: 以该种子初始化一个 `System.Random` 实例，并生成一个覆盖所有数据块索引的置换表 `π`。
3.  **数据块置换**: 将数据向量 `V` 分割为 `k` 个 8x8 字节的数据块 `B_0, B_1, ..., B_{k-1}`。根据置换表 `π`，生成置换后的数据向量 `V'`，其第 `i` 个块 `B'_i` 来自于原向量的第 `π(i)` 个块：`B'_i = B_{π(i)}`。

### 3. 载体图像生成

将处理后的数据向量 `V'`（如果执行了置换）或 `V`（如果未执行）写入载体图像 `I_C`。

1.  **载体尺寸**: 创建一个尺寸为 `W × 3H` 的新图像作为载体 `I_C`。
2.  **亮度通道写入**: 将向量 `V'` 的每个字节 `v'_i` 依次作为载体图像 `I_C` 中每个像素的 `Y` 值。`Cb` 和 `Cr` 值固定为 128（代表中性灰色）。
3.  **色彩空间反转**: 将每个载体像素的 `(Y=v'_i, Cb=128, Cr=128)` 转换回 RGB 色彩空间。
4.  **编码输出**: 将生成的 `I_C` 保存为 JPEG 图像。JPEG 的有损压缩可能会引入微小的数据偏差。

解码过程严格遵循上述步骤的逆序操作，通过相同的密码可重现完全相同的置换表，从而恢复原始数据。

## 安装

### 预编译版本
从 [Releases](https://github.com/app-pub/ImageScrambler/releases) 页面下载适用于操作系统的可执行文件。

### 从源码编译
确保已安装 [.NET SDK](https://dotnet.microsoft.com/download/dotnet/)。
```bash
git clone https://github.com/app-pub/ImageScrambler
cd ImageScrambler
dotnet build -c Release
```

### Native AOT 编译
若要编译为平台原生的独立可执行文件（以 Windows x64 为例）：
```bash
dotnet publish -c Release -r win-x64 --self-contained
```

## 使用方法

### 基本语法
```bash
ImageScrambler <命令> <输入文件> <输出文件> [密码] [选项]
```

### 命令
- `encode`: 将一个图像编码（隐藏）到载体图像中。
- `decode`: 从一个载体图像中解码（提取）隐藏的图像。
- `help`: 显示帮助信息。

### 参数与选项
| 参数/选项 | 缩写 | 说明 | 默认值 |
| :--- | :--- | :--- | :--- |
| `<输入文件>` | | 输入图像的路径。 | （必需） |
| `<输出文件>` | | 输出图像的路径。 | （必需） |
| `[密码]` | | 用于加密的密码。若不提供，将使用默认密码。 | "Default@Password" |
| `--quality` | `-q` | 输出 JPEG 图像的质量（1-100）。 | 100 |
| `--no-dct` | | 禁用数据块置换功能。 | （默认启用） |
| `--salt-context`| | 用于盐派生的自定义上下文。 | `CSC_SALT_DERIVATION` |
| `--salt-key` | | 用于盐派生的自定义密钥。 | `CSC_SALT_DERIVE` |
| `--salt-pattern`| | 用于盐派生的自定义模式（必须含`{0}`）。 | `CSC_SALT_DERIVE_{0}` |
| `--dct-context` | | 用于数据块置换的自定义上下文。 | `DCT_PERMUTATION` |
| `--blocks-context` | | 用于数据块置换的自定义上下文。 | `BLOCKS` |

### 示例
```bash
# 基本编码，使用自定义密码
ImageScrambler encode secret.png carrier.jpg "MyStrongPassword123"

# 编码并设置JPEG质量为90
ImageScrambler encode secret.png carrier.jpg "p@ssword" --quality 90

# 禁用数据块置换进行编码
ImageScrambler encode secret.png carrier.jpg "p@ssword" --no-dct

# 基本解码
ImageScrambler decode carrier.jpg extracted.png "MyStrongPassword123"
```

## 安全与技术说明

- **密码安全**: 默认密码 `"Default@Password"` 为公开发布、测试等目的而设的公共参数，**极不安全**。在实际使用中**务必**提供一个由自己设定的强密码。密码一旦丢失，数据将无法恢复。
- **数据置换非强加密**: 数据块置换功能使用 `System.Random`，它并非一个密码学安全的伪随机数生成器（CSPRNG）。因此，该功能主要用于数据混淆（Obfuscation），不应被视为能够抵抗恶意分析的强加密手段。
- **密钥派生**: 本工具使用自定义的、类似 HKDF 的结构来派生盐和种子。它并非标准的 PBKDF2 或 Argon2。
- **数据完整性**: 载体图像一经生成，应避免对其进行任何形式的二次编辑或压缩，否则可能导致数据损坏，解码失败。
- **输入格式**: 依赖于 ImageSharp 库，支持多种常见图像格式（PNG, JPEG, BMP, GIF 等）作为输入。
- **输出格式**: 所有输出均为 JPEG 格式。JPEG 的有损压缩特性意味着解码后的图像与原始图像可能存在微小的像素差异。当质量设置为100时，此差异通常可以忽略不计。
- **载体验证**: 解码时程序会检查载体图像的高度是否为 3 的倍数。这是验证其是否为有效载体的基本条件。

## 技术实现

- **图像处理**: [SixLabors/ImageSharp](https://github.com/SixLabors/ImageSharp)
- **加密原语**: `System.Security.Cryptography`，主要使用 `HMACSHA256` 和 `SHA256`。
- **性能优化**: 使用 `ArrayPool` 管理内存，通过 `Parallel.For` 进行并行处理以加速计算密集型任务。

## 免责与法律声明

**在使用本软件前，请仔细阅读并理解以下所有条款。**

1.  **软件按“原样”提供**：本软件按“原样”提供，不附带任何形式的明示或暗示的保证，包括但不限于对适销性、特定用途适用性和不侵权的保证。作者不保证软件的无错误、不中断运行或满足使用者的特定需求。

2.  **责任限制**：在任何情况下，本软件的作者或版权持有人均不对因使用、无法使用或滥用本软件及其功能所导致的任何索赔、损害或其他责任承担任何责任。这包括但不限于任何直接、间接、偶然、特殊、惩戒性或后果性的损害（如数据丢失、利润损失、业务中断、名誉损害、法律纠纷及相关费用等），无论其是如何产生以及基于何种责任理论（合同、侵权或其他），即使作者已被告知可能发生此类损害。

3.  **用户责任与法律合规**：本软件提供的信息隐藏功能，其预期用途仅限于技术研究和合法的个人数据保护。
    - **用户对所有行为负全部责任**：使用者必须对使用本软件执行的所有操作负完全的、不可推卸的责任。这包括使用者选择编码、隐藏、传输、分发及解码的所有数据和内容。
    - **遵守当地法律法规**：使用者有绝对义务确保使用者对本软件的使用行为完全符合使用者所在国家或地区的所有适用法律法规。这些法律法规可能涉及密码学使用、数据隐私、知识产权、版权、国家安全、以及对特定类型信息（如非法、诽谤、机密或受管制内容）的传播限制。
    - **禁止非法用途**：严禁使用本软件从事任何形式的非法活动。任何因非法使用本软件而产生的全部法律后果、风险和责任，均由用户本人独立承担，与本软件作者无任何关联。

4.  **最终解释权**：下载、安装、复制、分发或以任何方式使用本软件，即表示使用者已完全阅读、深刻理解并无条件同意接受本免责与法律声明的全部条款。若使用者不同意其中任何条款，请立即停止使用并从使用者的所有设备中彻底删除本软件。

## 许可证

本项目基于 MIT 许可证，同时作者保留所有权利。详情请参阅 [LICENSE](LICENSE) 文件。